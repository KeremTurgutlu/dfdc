# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/00_core.ipynb (unless otherwise specified).

__all__ = ['read_metadata', 'get_original_video_list', 'read_face_detection_df', 'run_command']

# Cell
from fastai.imports import *

# Cell
def read_metadata(fn):
    "read DFDC competition metadata as pd.DataFrame"
    metadf = pd.read_json(fn).T.reset_index()
    metadf.columns = ['fname','label','split','original']
    return metadf

# Cell
def get_original_video_list(path, metadf, dest=None):
    """
    get original video list from meta dataframe
    path: path of directory to video files
    dest: destination path to save the list
    """
    fnames = list(set(metadf['original'].dropna().values))
    video_files = pd.Series(list(map(lambda o: str(path/o), fnames)))
    if dest: video_files.to_csv(dest, index=False)
    return video_files

# Cell
def read_face_detection_df(path):
    df = pd.read_csv(path)
    df.face_detections = (df.face_detections.apply(lambda o: json.loads(o.replace("'", '"'))))
    return df

# Cell
import subprocess, shlex, datetime, json

# Cell
def _now(): return datetime.datetime.now().strftime("%m/%d/%Y, %H:%M:%S")

def _add_dict_to_json(fn, d):
    "Adds a dictionary to json-like file or creates one"
    assert type(d) == dict
    path = Path(fn)
    if path.exists(): l = json.loads(path.open().read())
    else: l = []
    l.append(d)
    with open(fn, "w") as f: f.write(json.dumps(l))

def run_command(command, logfn=None):
    "Run shell command as an external process, optionally write logs to logfn"
    if type(command) == str: command = shlex.split(command)
    elif type(command) == list: command = command
    else: raise AssertionError("Command should be string or list")
    process = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    stdout = []
    start_time = _now()
    while True:
        output = process.stdout.readline()
        if output == b'' and process.poll() is not None: break
        if output:
            _out = output.decode(); print(_out.strip())
            stdout.append(_out)
    end_time = _now()
    rc = process.poll()
    _, stderr =  process.communicate()
    err = stderr.decode(); print(err)
    out = "".join(stdout)
    if logfn:
        d = {"start_time": start_time, "end_time": end_time,
             "command": command, "stderr":err, "stdout":out}
        _add_dict_to_json(logfn, d)
    return rc